/**
*	created:		2012-6-20   19:54
*	filename: 		TextAsm
*	author:			FreeKnight
*	Copyright (C): 	
*	purpose:		
*/
//------------------------------------------------------------------------
#include "Asm.h"
//------------------------------------------------------------------------
WSERR _stdcall draw_ascii(WBmpStruct* bmp, char c)
{
/* 举例：大写字母A：0x14140800,0x223e2214,0x41, 3个数据每个表达3行象素，每行都是按照先低字节开始
	0x14140800=00010100 00010100 00001000 00000000
	0x223e2214=00100010 00111110 00100010 00010100
	0x41=01000001
	排列结果(8X9)：
	00000000
	00001000
	00010100
	00010100
	00010100
	00100010
	00111110
	00100010
	01000001
*/
	int w,h;
	static unsigned int ascii[]={
		0x8080800,0x80808,0x8,	// 33 !
		0x242424,0x0,0x0,
		0x3f0a0a00,0x287e1414,0x28,
		0x28281e08,0xa0a0c18,0x83c,
		0x4c4a3100,0x29190e38,0x46,
		0x48483000,0x46444a32,0x39,
		0x80808,0x0,0x0,
		0x10080c06,0x10101010,0x60c08,
		0x4081820,0x4040404,0x301808,
		0x18360800,0x14,0x0,
		0x8000000,0x8087f08,0x8,
		0x0,0x18000000,0x100818,
		0x0,0x3e00,0x0,
		0x0,0x18000000,0x18,
		0x4020201,0x10100804,0x402020,
		0x42243c00,0x24424242,0x3c,
		0x8380800,0x8080808,0x3e,
		0x2023c00,0x20100806,0x3e,
		0x4043c00,0x4040418,0x38,
		0x140c0400,0x47e4424,0x4,
		0x20203c00,0x4040438,0x38,
		0x20100e00,0x2222322c,0x1c,
		0x4023e00,0x20101008,0x20,
		0x22221c00,0x2222241c,0x1c,
		0x22221c00,0x4021e22,0x38,
		0xc000000,0xc00000c,0xc,
		0x18000000,0x18000018,0x100818,
		0x2000000,0xc10100c,0x2,
		0x0,0x3e003e,0x0,
		0x20000000,0x18040418,0x20,
		0x2223c00,0x80804,0x8,
		0x4e221c00,0x205b5652,0x1c,
		0x14140800,0x223e2214,0x41, // 65 A
		0x22223c00,0x2222223c,0x3c,
		0x40201e00,0x20404040,0x1e,
		0x42447800,0x44424242,0x78,
		0x20203e00,0x20203c20,0x3e,
		0x20203e00,0x20203c20,0x20,
		0x40201e00,0x22424e40,0x1e,
		0x22222200,0x2222223e,0x22,
		0x8083e00,0x8080808,0x3e,
		0x4043c00,0x4040404,0x78,
		0x28242200,0x24283030,0x22,
		0x20202000,0x20202020,0x3e,
		0x6a666600,0x42525a5a,0x42,
		0x32322200,0x26262a2a,0x22,
		0x42243c00,0x24424242,0x3c,
		0x22223c00,0x20203c22,0x20,
		0x42243c00,0x24424242,0x3041c,
		0x22223c00,0x24283824,0x22,
		0x20201e00,0x2020418,0x3c,
		0x8087f00,0x8080808,0x8,
		0x22222200,0x22222222,0x1c,
		0x22224100,0x1c141422,0x8,
		0x49414100,0x36363549,0x22,
		0x14224100,0x22140808,0x41,
		0x14224100,0x8080814,0x8,
		0x4027e00,0x40201008,0x7e,
		0x808080f,0x8080808,0xf0808,
		0x10202040,0x4040810,0x10202,
		0x404043c,0x4040404,0x3c0404,
		0x14180808,0x222414,0x0,
		0x0,0x0,0x7f00,
		0x810,0x0,0x0,
		0x1c000000,0x22221e02,0x1f,
		0x2c202020,0x22222232,0x3c,
		0x1e000000,0x20202020,0x1e,
		0x1e020202,0x26222222,0x1a,
		0x1c000000,0x20203e22,0x1e,
		0x7e10100e,0x10101010,0x10,
		0x1e000000,0x22222222,0x1c021e,
		0x2e202020,0x22222232,0x22,
		0x38000008,0x8080808,0x8,
		0x3c000004,0x4040404,0x380404,
		0x22202020,0x24283824,0x22,
		0x8080838,0x8080808,0x8,
		0x5b000000,0x4949496d,0x49,
		0x2e000000,0x22222232,0x22,
		0x3c000000,0x42424242,0x3c,
		0x2c000000,0x22222232,0x20203c,
		0x1e000000,0x22222222,0x2021e,
		0x2e000000,0x20202032,0x20,
		0x1e000000,0x2063820,0x3c,
		0x7e101000,0x10101010,0xe,
		0x22000000,0x26222222,0x3a,
		0x41000000,0x14142222,0x8,
		0x41000000,0x36555549,0x22,
		0x42000000,0x24181824,0x42,
		0x42000000,0x18182424,0x601010,
		0x7e000000,0x20100804,0x7e,
		0x808080e,0x8083008,0x60808,
		0x8080808,0x8080808,0x80808,
		0x8080830,0x8080608,0x380808,
		0x0,0x4e3900,0x0, // 126 ~
		0x22223e00,0x22222222,0x3e // 127
	};
	__asm
	{
		movzx eax,byte ptr c			; 读入 ascii 字符
		mov esi,offset ascii[0]			; ascii字符数字首地址
		sub eax,33						; ascii-33,因为前面0~32不绘制
		mov edx,bmp						; edx=bmp位图
		shl eax,2						; eax=eax*4,因为ascii数组里面的每个值用4个字节表达
		mov ebx,[edx]WBmpStruct.ky		; ebx=bmp->ky
		lea eax,[eax+2*eax]				; eax=eax*3,因为每个字符在ascii数组里面用3个uint表达
		xor ecx,ecx						; ecx=0
		add esi,eax						; esi 指向字体数据
		cmp ebx,0
		jge _y_gt_top					; 没有被上边界裁掉?
		sub ecx,ebx						; 上边界-y = 裁掉的行数
		cmp ecx,12
		jl _skip1
		jmp _end
_skip1:
		add ebx,ecx
_y_gt_top:
		cmp ebx,[edx]WBmpStruct.h
		jl _skip2
		jmp _end
_skip2:
		mov edi,ebx
		add esi,ecx
		imul edi,[edx]WBmpStruct.pitch
		sub ecx,12
		add edi,[edx]WBmpStruct.ptr		; edi 位图行准备写汉字的行指针
		sub ebx,ecx
		neg ecx
		cmp ebx,[edx]WBmpStruct.h
		jle _bnoclip;
		add ecx,[edx]WBmpStruct.h
		sub ecx,ebx
_bnoclip:								; ecx 准备画多少行
		mov ebx,[edx]WBmpStruct.kx
		mov h,ecx
		xor ecx,ecx

		cmp ebx,0
		jge _x_gt_left					; 没有被左边界裁掉?
		sub ecx,ebx						; 左边界-x = 裁掉的列数
		cmp ecx,7
		jge _end;
		add ebx,ecx
_x_gt_left:
		cmp ebx,[edx]WBmpStruct.w
		jge _end
		mov eax,ecx
		lea edi,[edi+2*ebx]
		sub ecx,7
		sub ebx,ecx
		neg ecx
		cmp ebx,[edx]WBmpStruct.w
		jle _rnoclip
		add ecx,[edx]WBmpStruct.w
		sub ecx,ebx
_rnoclip:								; ecx 准备画多少列
		add eax,ecx
		sub eax,7
		neg eax
		mov c, al

		mov eax,[edx]WBmpStruct.userdata
		mov edx,[edx]WBmpStruct.pitch
		sub edx,ecx
		sub edx,ecx
		dec ecx
		mov w,ecx
_nextline:
		mov cl, c
		mov bl,[esi]
		shr ebx,cl
		mov ecx,w
_loop:
		bt ebx,ecx
		jnc _skip
		mov [edi],ax
_skip:
		add edi,2
		dec ecx
		jns _loop
		inc esi
		add edi,edx
		dec h
		jnz _nextline
_end:
	}
	return WS_OK;
}
//------------------------------------------------------------------------